<?xml version="1.0" encoding="UTF-8"?>
<chapter id="message-channel">
    <title>Message channel support</title>

    <para>Spring Integration (http://www.springsource.org/spring-integration) provides support for messaging solutions in
    Spring-based applications meeting the famous Enterprise Integration patterns and best practices. Citrus itself uses a lot 
    of Spring's API's and especially those from Spring Integration.</para>
    
    <para>The conclusion is that Citrus supports the sending and receiving of messages to/from Spring Integration message 
    channel components.</para>
    
    <note>
        <para>Citrus message channel connecting components use the same "citrus" configuration namespace and schema definitions
        in Spring context files as already described in chapter <xref linkend="jms"/>. You always have to include this configuration 
        namespace in order to use the Citrus configuration elements.</para>
    </note>
    
    <section id="message-chanel-sender">
        <title>Message channel sender</title>
        
        <para>You can access message channels directly with a <emphasis>message-channel-sender</emphasis> component. The message 
        channel sender configuration is quite simple and receives a target channel as reference:</para>
        
        <programlisting>
  &lt;citrus:message-channel-sender id=&quot;orderRequestSender&quot; 
                              channel=&quot;orderChannel&quot;/&gt;
        </programlisting> 
        
        <para>You can also set a message channel template that will actually send the messages. This is optional as 
        Citrus will create a default message channel template by default.</para>
        
        <programlisting>
  &lt;citrus:message-channel-sender id=&quot;statusRequestSender&quot;
                              channel=&quot;orderChannel&quot; 
                              message-channel-template=&quot;myMessageChannelTemplate&quot;/&gt;
        </programlisting>
    </section>
    
    <para>The message sender is now ready to publish messages to the defined channel. The communication is supposed to be asynchronous, 
    so the sender is not able to process a reply message. We will deal with synchronous communication and reply messages later in this chapter.
    The message sender just publishes the messages to the channel.</para>
    
    <section id="message-channel-receiver">
        <title>Message channel receiver</title>
        
        <para>Citrus is able to receive messages from message channel destinations. Again the message-channel-receiver needs nothing but a 
        reference to a message channel.</para>
        
        <programlisting>
  &lt;citrus:message-channel-receiver id=&quot;ordersResponseReceiver&quot; 
                                  channel=&quot;orderChannel&quot;
                                  receive-timeout=&quot;5000&quot;/&gt;
        </programlisting>
        
        <para>As usual the receiver connects to the message destination and waits for messages to arrive. The user can set a receive timeout which is 
        set to 5000 milliseconds by default. In case no message is received in this time frame the sender and the test will fail with error.</para>
        
        <para>Similar to the previously described <emphasis>message-channel-sender</emphasis> the <emphasis>message-channel-receiver</emphasis> supports
        a message-channel-template that is explicitly set for receiving messages.</para>
    </section>
    
    <section id="sync-message-channel-sender">
        <title>Synchronous message channel sender</title>
        
        <para>Synchronous message senders publish messages to channels and waits synchronously for the response to arrive on some temporary reply 
        channel destination. The reply channel name is set in the message's header attributes so the counterpart in this communication can send its reply 
        to that temporary channel. The basic configuration for a synchronous send-receive message channel sender looks like follows:</para>
        
        <programlisting>
  &lt;citrus:sync-message-channel-sender id=&quot;customerRequestSender&quot; 
                              channel=&quot;customerRequestChannel&quot;
                              reply-channel=&quot;customerResponseChannel&quot;
                              reply-handler=&quot;customerReplyMessageHandler&quot;
                              reply-timeout=&quot;1000&quot;/&gt;
                              
  &lt;citrus:message-channel-reply-handler id=&quot;customerReplyMessageHandler&quot;/&gt;      
        </programlisting>
        
        <para>Synchronous message channel senders usually go with a reply message handler that handles the reply messages. Once the synchronous reply 
        message was received on the temporary reply destination the reply-message-handler implementation is responsible for further processing (e.g. message validation).</para>
        
        <note>
            <para>Reply channels are always of dynamic temporary nature. The temporary reply channels are only used once for a single communication handshake. 
            After that the reply channel is deleted again. Static reply channels are not supported because they would receive multiple reply messages at the same
            time and the reply message handlers need to filter (select) the message from that channel, which is not in scope yet.</para>
        </note>
    </section>
    
    <section id="sync-message-channel-receiver">
        <title>Synchronous message channel receiver</title>
        
        <para>In the last section we saw that synchronous communication is based on reply messages that are sent to temporary reply channels. Now Citrus has
        to support this dynamic reply sending to temporary channels, too. The scenario we are talking about is that Cittrus receives a message through a 
        message channel where the reply must be sent to a temporary reply channel that is stored in the message header attributes.</para>
        
        <para>We handle this synchronous communication with the synchronous message receiver in combination with a reply sender.</para>
        
        <programlisting>
  &lt;citrus:sync-message-channel-receiver id=&quot;orderRequestReceiver&quot; 
                      channel=&quot;order&quot;/&gt;
                                       
  &lt;citrus:message-channel-reply-sender id=&quot;orderReplySender&quot;
                      reply-channel-holder=&quot;orderRequestReceiver&quot;/&gt;
        </programlisting>
        
        <para>The synchronous message channel receiver will store dynamic reply channel destinations and provide those
        to a reply message sender. Those two components <emphasis>sync-message-channel-receiver</emphasis> and 
        <emphasis>message-channel-reply-sender</emphasis> are always working together in order to realize incoming synchronous
        request with additional reply message sent by Citrus.</para>
    </section>
    
</chapter>