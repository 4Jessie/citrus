<?xml version="1.0" encoding="UTF-8"?>
<chapter id="messaging">
  <title>Messaging</title>

  <para>In one of the previous chapters we have discussed the basic test case structure as we introduced <emphasis>variables</emphasis> and
  <emphasis>test actions</emphasis>. The &lt;actions&gt; section contains a list of test actions that take place during the test case. 
  Each test action is executed in sequential order by default. Citrus offers several built-in test actions that the user can choose from to construct a complex
  testing workflow without having to code everything from scratch. In particular Citrus aims to provide all the test actions that you need as predefined components 
  ready for you to use. The goal is to minimize the coding effort for you so you can concentrate on the test logic itself. All available test actions are discussed 
  in the next sections.</para>
  
  <para>As sending and receiving messages is essential in integration testing of message-based architectures we will handle these actions in first place.
  But first of all lets have a look at the common message interface in Citrus:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" width="200px" scale="100" fileref="figure_001.jpg" format="JPG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="figure_001.jpg" format="JPG" />
    </imageobject>
  </mediaobject>
  
  <para>A message consists of a message header (name-value pairs) and a message payload. Later in this document we will see how 
  a test constructs several messages with payload and header values. But first of all let's concentrate on sending and receiving 
  messages to/from various transports. MesageSender and MessageReceiver components play a significant role in this respect. The next figure shows a 
  typical MessageSender component in Citrus:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" width="450px" scale="100" fileref="figure_002.jpg" format="JPG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="figure_002.jpg" format="JPG" />
    </imageobject>
  </mediaobject>

  <para>The MessageSender publishes messages to a destination. This destination can be a JMS queue/topic, a SOAP WebService endpoint, a Http URL, a FTP folder destination 
  and many more. The MessageSender component just takes a previously defined message definition (header and payload) and sends it to the message destination.</para>
  
  <para>Similar to that Citrus defines the several MessageReceiver components to consume messages from destinations. This can be a simple subscription
  on message channels and JMS queues/topics. In case of SOAP WebServices and Http GET/POST things are more complicated as we have to provide a 
  server component that clients can connect to. We will handle this Http server related communication later in this document. For now
  a MessageReceiver component in its most simple way is defined like this:</para>
  
  <mediaobject>
    <imageobject role="fo">
      <imagedata align="center" width="450px" scale="100" fileref="figure_003.jpg" format="JPG" />
    </imageobject>
    
    <imageobject role="html">
      <imagedata align="center" display="block" fileref="figure_003.jpg" format="JPG" />
    </imageobject>
  </mediaobject>
  
  <para>In the next sections you will learn how a test case uses those MessageSender and MessageReceiver components for publishing and consuming 
  messages.</para>
  
  <section id="message-sending">
    <title>Sending messages</title>

    <para>The &lt;send&gt; action publishes messages to a destination. The message transport which is used under the hood does not
    matter to the test case - for now. The test case simply defines the message contents and uses a predefined message sender components to actually 
    publish the constructed message to a destination. There are several message sender implementations in Citrus available representing different transport 
    protocols like JMS, SOAP, HTTP, TCP/IP and many more.</para>
     
    <para>Again the type of transport to use is not specified inside the test case but in the message sender definition. The separation of concerns (test case/message sender transport) 
    gives us a good flexibility of our test cases. The test case does not know anything about connection factories, queue names or endpoint urls, connection timeouts and so on. The transport 
    internals underneath a sending test action can change easily without affecting the test case definition. We will see later in this document how to create different message senders for 
    various transports in Citrus. For now we concentrate on constructing the message content to be sent.</para>
    
    <para>We assume that the message's payload will be plain XML format. Citrus uses XML as the default data format for message payload data. But Citrus is not limited to XML message format 
    though; you can always define other message data formats such as JSON, plain text, CSV. As XML is still a very popular message format in enterprise applications and message-based solution
    architectures we have this as a default format. Anyway Citrus works best on XML payloads and you will see a lot of example code in this document using XML. Finally let us have a look at a 
    first example how a sending action is defined in the test.</para>
    
    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;testcase name=&quot;SendMessageTest&quot;&gt;
    &lt;description&gt;Basic send message example&lt;/description&gt;
    &lt;variables&gt;
        &lt;variable name=&quot;text&quot; value=&quot;Hello Citrus!&quot;/&gt;
        &lt;variable name=&quot;messageId&quot; value=&quot;Mx1x123456789&quot;/&gt;
    &lt;/variables&gt;
    &lt;actions&gt;
        &lt;send with=&quot;helloServiceClient&quot;&gt;
            &lt;message&gt;
                &lt;payload&gt;
                    &lt;TestMessage&gt;
                        &lt;Text&gt;${text}&lt;/Text&gt;
                    &lt;/TestMessage&gt;
                &lt;/payload&gt;
            &lt;/message&gt;
            &lt;header&gt;
                &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
                &lt;element name=&quot;MessageId&quot; value=&quot;${messageId}&quot;/&gt;
            &lt;/header&gt;
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>
    
    <para>The sample uses both header and payload as message parts to send. In both parts you can use variable definitions
    (see <emphasis>${text}</emphasis> and <emphasis>${messageId}</emphasis>). So first of all let us recap what variables do.
    Test variables are defined at the very beginning of the test case and are valid throughout all actions that take place in
    the test. This means that actions can simply reference a variable by the expression <literal>${variable-name}</literal>.</para>
    
    <tip>
        <para>Use variables wherever you can! At least the important entities of a test should be defined as variables at the 
        beginning. The test case improves maintainability and flexibility when using variables.</para>
    </tip>
    
    <para>Now lets have a closer look at the sending action. The 'with' attribute might catch your attention first.
    This attribute references a message endpoint in Citrus configuration by name. As previously mentioned the message endpoint
    definition lives in a separate configuration file and contains the actual message transport settings. In this example the
    <emphasis>&quot;helloServiceClient&quot;</emphasis> is referenced which is a special client endpoint for sending out messages via
    HTTP for instance.</para>
    
    <para>The test case is not aware of any transport details, because it does not have to. The advantages are obvious: On the one hand multiple test
    cases can reference the message endpoint definition for better reuse. Secondly test cases are independent of message transport details.
    So connection factories, user credentials, endpoint uri values and so on are not present in the test case.</para>
    
    <para>In other words the <emphasis>&quot;with&quot;</emphasis> attribute of the <emphasis>&lt;send&gt;</emphasis> element specifies
    which message endpoint definition to use and therefore where the message should go to. Once again all available message endpoints are
    configured in a separate Citrus configuration file. We will come to this later on. Be sure to always pick the right message endpoint type
    in order to publish your message to the right destination.</para>
    
    <para>If you do not like the XML language you can also use pure Java code to define the same test. In Java you would also make use of the message endpoint
    definition and reference this instance. The same test as shown above in Java DSL looks like this:</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">import org.testng.ITestContext;
import org.testng.annotations.Test;
import com.consol.citrus.dsl.annotations.CitrusTest;
import com.consol.citrus.dsl.TestNGCitrusTestBuilder;

@Test
public class SendMessageTest extends TestNGCitrusTestBuilder {

    @CitrusTest(name = "SendMessageTest")
    public void sendMessageTest() {
        description("Basic send message example");
    
        variable("text", "Hello Citrus!");
        variable("messageId", "Mx1x123456789");
    
        send("helloServiceClient")
            .payload("&lt;TestMessage&gt;" +
                        "&lt;Text&gt;${text}&lt;/Text&gt;" +
                    "&lt;/TestMessage&gt;")
            .header("Operation", "sayHello")
            .header("RequestTag", "${messageId}");
    }
}</programlisting>

    <para>Instead of using the XML tags for send we use methods from <emphasis>TestNGCitrusTestBuilder</emphasis> class. The same message endpoint
    is referenced within the send message action. The payload is constructed as plain Java character sequence which is a bit verbose. We will see
    later on how we can improve this. For now it is important to understand the combination of send test action and a message endpoints.</para>
    
    <tip>
        <para>It is good practice to follow naming conventions when defining names for message endpoints. The intended purpose of the message
        endpoint as well as the sending/receiving actor should be clear when choosing the name. For instance messageEndpoint1,
        messageEndpoint2 will not give you much hints to the purpose of the message endpoint.</para>
    </tip>
    
    <para>Now that the message sender pattern is clear we can concentrate on how to specify the message content to be sent. 
    There are several possibilities for you to define message content in Citrus:</para>
        
    <itemizedlist mark="opencircle">
        <listitem>
            <para><emphasis>message</emphasis>: This element constructs the message to be sent. There are several child elements available:</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>payload</emphasis>: Nested XML payload as direct child node.</para>
                </listitem>
                <listitem>
                    <para><emphasis>data</emphasis>: Inline CDATA definition of the message payload</para>
                </listitem>
                <listitem>
                    <para><emphasis>resource</emphasis>: External file resource holding the message payload</para>
                    <para>The syntax would be: &lt;resource file="classpath:com/consol/citrus/messages/TestRequest.xml" /&gt;</para>
                    <para>The file path prefix indicates the resource type, so the file location is resolved either as file system resource (file:) 
                    or classpath resource (classpath:).</para>
                </listitem>
                <listitem>
                    <para><emphasis>element</emphasis>: Explicitly overwrite values in the XML message payload using XPath. You can replace message content 
                    with dynamic values before sending. Each &lt;element&gt; entry provides a &quot;path&quot; and &quot;value&quot; attribute. The &quot;path&quot; 
                    gives a XPath expression evaluating to a XML node element or attribute in the message. The &quot;value&quot; can be a variable expression or any other 
                    static value. Citrus will replace the value before sending the message.</para>
                </listitem>
            </itemizedlist>
        </listitem>
        <listitem>
            <para><emphasis>header</emphasis>: Defines a header for the message (e.g. JMS header information or SOAP header):</para>
            <itemizedlist mark="opencircle">
                <listitem>
                    <para><emphasis>element</emphasis>: Each header receives a &quot;name&quot; and &quot;value&quot;. The &quot;name&quot; will be the 
                    name of the header entry and &quot;value&quot; its respective value. Again the usage of variable expressions as value is supported here, too.</para>
                </listitem>
            </itemizedlist>
        </listitem>
    </itemizedlist>
    
    <para>The most important thing when dealing with sending actions is to prepare the message payload and header. You are able to construct the message payload either by 
    nested XML chil nodes (payload), as inline CDATA (&lt;data&gt;) or external file (&lt;resource&gt;). Before sending takes place you can explicitly overwrite some message
    values explicitly. You can think of overwriting specific message elements with variable values for instance. The example above uses the variable ${text} directly in the
    XML payload definition. In addition to that you can use XPath expressions for overwriting message contents before sending. The two approaches of overwriting message
    elements before sending can coexist simultaneously.</para>
     
    <para>The message header is part of our duty of defining proper messages, too. So Citrus uses name-value pairs like &quot;Operation&quot; and &quot;MessageId&quot; in the
    example above to set message header entries. Depending on what message endpoint is used and which message transport underneath the header values will be shipped in different ways.
    In JMS the headers go to the header section of the message, in Http we set mime headers accordingly, in SOAP we can access the SOAP header elements and so on. Citrus aims to do
    the hard work for you. So Citrus knows how to set headers on different message transports.</para>
    
    <note>
      <para>Sometimes the nested XML message payload elements may cause XSD schema validation rule violations. This is because of variable values not fitting the XSD schema rules
      for example. In this scenario you could also use simple CDATA sections as payload data. In this case you need to use the <literal>&lt;data&gt;</literal> element in contrast
      to the <literal>&lt;payload&gt;</literal> element that we have used in our examples so far.</para>

      <para>With this alternative you can skip the XML schema validation from your IDE at design time. Unfortunately you will loose the XSD auto completion features many XML editors
      offer when constructing your payload. See following example for usage explanation:</para>
      
      <programlisting>&lt;testcase name=&quot;sendMessageTest&quot;&gt;
    &lt;actions&gt;
        &lt;send with=&quot;helloServiceClient&quot;&gt;
            &lt;message&gt;
                &lt;data&gt;
                    &lt;![CDATA[
                    &lt;hlo:HelloRequest xmlns:hlo=&quot;http://www.consol.de/schemas/samples/sayHello.xsd&quot;&gt;
                        &lt;hlo:Text&gt;Hello Citrus!&lt;/hlo:Text&gt;
                    &lt;/hlo:HelloRequest&gt;
                    ]]&gt;
                &lt;/data&gt;
            &lt;/message&gt;
            ...
        &lt;/send&gt;
    &lt;/actions&gt;
&lt;/testcase&gt;</programlisting>

      <para>This alternative works for receiving message actions, too. We will see this in the next sections.</para>
    </note>
    
    <para>This is basically how to send messages in Citrus. The test case is responsible for constructing the message content while the predefined message endpoint holds transport specific
    settings. Test cases reference endpoint components to publish messages to the outside world. The variable support in message payload and message header
    enables you to add dynamic values before sending out the message.</para>
  </section>
  
  <section id="message-receiving">
    <title>Receiving messages</title>

    <para>Now we have a look at the message receiving part inside the test. A simple example shows how it works.</para>
    
    <para><emphasis>XML DSL</emphasis></para>
    <programlisting>&lt;receive with=&quot;helloServiceServer&quot;&gt;
    &lt;message&gt;
        &lt;payload&gt;
            &lt;TestMessage&gt;
                &lt;Text&gt;${text}&lt;/Text&gt;
            &lt;/TestMessage&gt;
        &lt;/payload&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;MessageId&quot; value=&quot;${messageId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>
    
    <para>If we recap the send action of the previous chapter we can identify some common mechanisms that apply for both
    sending and receiving actions. This time the test uses a predefined message server endpoint in order to receive the message.
    Again the test is not aware of the transport details such as JMS connections, endpoint uri, and so on. The message endpoint
    component encapsulates this information.</para>
    
    <para>Before we go into detail on validating the received message we have a quick look at the Java DSL variation for the
    receive action. The same receive action as above looks like this in Java DSL.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void messagingTest() {
    receive("helloServiceServer")
        .payload("&lt;TestMessage&gt;" +
                    "&lt;Text&gt;${text}&lt;/Text&gt;" +
                "&lt;/TestMessage&gt;")
        .header("Operation", "sayHello")
        .header("MessageId", "${messageId}");
}</programlisting>
    
    <para>While the action tries to receive a message the whole test execution will be delayed. This is
    important to ensure the step by step test workflow processing. At this time the test case waits for the message to arrive.
    Of course you can specify message timeouts so the receiver will only wait a given amount of time. Following from that a timeout exception fails 
    the test in case the message does not arrive in time. Citrus defines default timeout settings for all message receiving tasks.</para>
    
    <para>In best case the message has arrived in time and the content can be validated as next step. This validation can be done in various ways. 
    On the one hand you can specify a whole XML message that you expect as control template. In this case the received XML structure will
    be compared to the expected XML message content element by element. On the other hand you can use explicit element validation where only a 
    small subset of message elements is included into validation.</para>
    
    <para>Besides the message payload Citrus will also perform validation on the received message header values. Test variable usage is 
    supported as usual during the whole validation process for payload and header checks.</para>
    
    <para>In general the validation component (validator) in Citrus works hand in hand with a message reveiving component as the following
    figure shows:</para>
    
    <mediaobject>
      <imageobject role="fo">
        <imagedata align="center" display="block" fileref="figure_005.jpg" format="JPG" />
      </imageobject>
      
      <imageobject role="html">
        <imagedata align="center" display="block" fileref="figure_005.jpg" format="JPG" />
      </imageobject>
    </mediaobject>
   
    <para>The message receiving component passes the message to the validator where the individual validation steps are performed. Let us have a closer 
    look at the validation options and features step by step.</para>
    
    <section id="message-payload-validation">
        <title>Validate message content</title>
        
        <para>Once Citrus has received a message the tester can validate the message contents in various ways. First of all the tester can compare 
        the whole message payload to a predefined control message template.</para>
        
        <para>The receiving action offers following XML elements for control message templates:</para>
        <itemizedlist mark="opencircle">
            <listitem>
                <para><emphasis>&lt;data&gt;</emphasis>: Defines an inline XML message template as nested CDATA</para>
            </listitem>
            <listitem>
                <para><emphasis>&lt;resource&gt;</emphasis>: Defines an expected XML message template via external file resources</para>
            </listitem>
        </itemizedlist>
        
        <para>Both ways inline CDATA XML or external file resource give us a control message template. Citrus uses this
        control template for extended XML tree comparison. All elements, namespaces, attributes and node values are validated in XML DOM tree comparison.
        Only in case received message and control message are equal to each other the message validation will succeed. In case differences occur Citrus gives
        detailed error messages and the test fails.</para>
        
        <para>Now up to now the control message template is very static. Message comparison in this high extend has to be much more robust. This is why Citrus supports
        various ways to add dynamic message content and ignored elements to the XML tree validation. The tester can enrich the expected message template with test variables 
        or some elements can be completely ignored in validation.</para>
        
        <para>The Java DSL has a significant disadvantage. Java does not support multiline character sequence values as Strings. Thisb is why you have to use verbose String
        concatenation when constructing XML message payload content. In addition to that reserved characters like quotes must be escaped and line breaks must be explicitly added.
        All these impediments let me suggest to use external file resources in Java DSL when dealing with large complex XML data.</para>
        
        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("getCustomerResponseReceiver")
        .payload(new ClassPathResource("com/consol/citrus/message/data/GetCustomerResponse.xml"))
        .header("Operation", "GetCustomer")
        .header("RequestTag", "${requestTag}");
}</programlisting>
    </section>
    
    <section id="message-dynamic-validation">
        <title>Dynamic message values</title>
        
        <para>Some elements in our message payload might be of variable nature. Just think of identifiers that should not be static in our expected message template.
        Instead of repeating the ids several times hardcoded in our test we overwrite those elements with variable values. This can be done with XPath or inline variable
        declarations. Lets have a look at a example listing showing both ways to overwrite message tempalte content before validation:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;message&gt;
    &lt;data&gt;
        &lt;![CDATA[
        &lt;RequestMessage&gt;
            &lt;MessageHeader&gt;
                &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
                &lt;RequestTag&gt;_&lt;/RequestTag&gt;
                &lt;VersionId&gt;2&lt;/VersionId&gt;
            &lt;/MessageHeader&gt;
            &lt;MessageBody&gt;
                &lt;Customer&gt;
                    &lt;Id&gt;1&lt;/Id&gt;
                &lt;/Customer&gt;
            &lt;/MessageBody&gt;
        &lt;/RequestMessage&gt;
        ]]&gt;
    &lt;/data&gt;
    &lt;element path=&quot;//MessageHeader/RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
&lt;/message&gt;</programlisting>
        
        <para>The program listing shows both ways of setting variable values inside a message template. First of all you can
        simply place variable expressions inside the message (see how ${correlationId} is used). Secondly you can also use 
        XPath expressions to explicitly overwrite message elements before validation.</para>
        
        <para><literal>&lt;element path=&quot;//MessageHeader/RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;</literal></para>
        
        <para>The XPath expression evaluates to the message template, searches for the right element and replaces the element value. Of course 
        this works with attributes too.</para>
        
        <para>Both ways via XPath or inline variable expressions are equal to each other. With respect to the complexity of XML namespaces and XPath you may
        find the inline variable expression more comfortable to use. Anyway feel free to choose the way that fits best for you. This is how we can add dynamic variable
        values to the control template in order to increase maintainability and robustness of message validation.</para>
        
        <tip>Validation matchers put validation mechanisms to a new level offering dynamic assertion statements for validation. Have a look at the possibilities with 
        assertion statements in <xref linkend="validation-matchers"/></tip>
    </section>
    
    <section id="message-validation-ignore">
        <title>Ignore message elements</title>
        
        <para>Some elements in the message payload might not apply for validation at all. Just think of communication timestamps an dynamic values inside a 
        message:</para>
        
        <programlisting>[...]
    &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
[...]</programlisting>
        
        <para>The timestamp value will dynamically change from test run to test run and is hardly predictable for the tester, so lets ignore it in validation.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting> &lt;message&gt;
    &lt;data&gt;
        &lt;![CDATA[
        &lt;ResponseMessage&gt;
            &lt;MessageHeader&gt;
                &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                &lt;Timestamp&gt;2001-12-17T09:30:47.0Z&lt;/Timestamp&gt;
                &lt;RequestTag&gt;${requestTag}&lt;/RequestTag&gt;
                &lt;VersionId&gt;2&lt;/VersionId&gt;
            &lt;/MessageHeader&gt;
            &lt;MessageBody&gt;
                &lt;Customer&gt;
                    &lt;Id&gt;1&lt;/Id&gt;
                &lt;/Customer&gt;
            &lt;/MessageBody&gt;
        &lt;/ResponseMessage&gt;
        ]]&gt;
    &lt;/data&gt;
    &lt;ignore path=&quot;//ResponseMessage/MessageHeader/Timestamp&quot;/&gt;
&lt;/message&gt;</programlisting>
        
        <para>If you do not like XPath you could also use another possibility to ignore message contents. The next example uses the special <emphasis>@ignore@</emphasis> placeholder
        directly in the message content:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;message&gt;
    &lt;data&gt;
        &lt;![CDATA[
        &lt;ResponseMessage&gt;
            &lt;MessageHeader&gt;
                &lt;CorrelationId&gt;${correlationId}&lt;/CorrelationId&gt;
                &lt;Timestamp&gt;@ignore@&lt;/Timestamp&gt;
                &lt;RequestTag&gt;${requestTag}&lt;/RequestTag&gt;
                &lt;VersionId&gt;2&lt;/VersionId&gt;
            &lt;/MessageHeader&gt;
            &lt;MessageBody&gt;
                &lt;Customer&gt;
                    &lt;Id&gt;1&lt;/Id&gt;
                &lt;/Customer&gt;
            &lt;/MessageBody&gt;
        &lt;/ResponseMessage&gt;
        ]]&gt;
    &lt;/data&gt;
&lt;/message&gt;</programlisting>
        
        <para>The ignored message elements are automatically skipped when Citrus compares and validates message contents.</para>
        
        <para>When using Java as the test case DSL the <emphasis>@ignore@</emphasis> placeholder as well as XPath expression ignore can be used seamlessly. Here is an examnple
        if you need clarification:</para>
        
        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("getCustomerResponseReceiver")
        .payload(new ClassPathResource("com/consol/citrus/message/data/GetCustomerResponse.xml"))
        .header("Operation", "GetCustomer")
        .header("RequestTag", "${requestTag}")
        .ignore("//ResponseMessage/MessageHeader/Timestamp");
}</programlisting>
    </section>
    
    <section id="message-validation-elements">
        <title>Explicit message element validation</title>
        
        <para>In the previous sections we have seen how to validate whole XML fragments with control message templates. In some cases 
        this approach might be too extensive. Imagine the tester only needs to validate a small subset of message elements. The definition 
        of control templates in combination with several ignore statements is not appropriate in this case. You would rather want
        to use explicit element validation.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;message&gt;
  &lt;validate path=&quot;//MessageHeader/RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
  &lt;validate path=&quot;//CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
  &lt;validate path=&quot;//MessageBody/Number&quot; value=&quot;123456789&quot;/&gt;
&lt;/message&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("getCustomerResponseReceiver")
        .validate("//MessageHeader/RequestTag", "${requestTag}")
        .validate("//CorrelationId", "${correlationId}")
        .validate("//MessageBody/Number", "123456789")
        .header("Operation", "GetCustomer")
        .header("RequestTag", "${requestTag}");
}</programlisting>  
        
        <para>Instead of comparing the whole message some message elements are validated explicitly over XPath. Citrus evaluates the XPath expression on the received message and 
        compares the result value to the control value. The basic message structure as well as all other message elements are not included into this explicit validation.</para> 
        
        <note>
            <para>If this type of element validation is chosen neither &lt;data&gt; nor &lt;resource&gt; template definitions are allowed in XML.</para>
        </note>
        
        <tip>
            <para>Citrus offers an alternative dot-notated syntax in order to walk through XML trees. In case you are not 
            familiar with XPath or simply need a very easy way to find your element inside the XML tree you might use this way. Every 
            element hierarchy in the XML tree is represented with a simple dot - for example:</para>
            
            <para><literal>message.body.text</literal></para>
            
            <para>The expression will search the XML tree for the respective &lt;message&gt;&lt;body&gt;&lt;text&gt; element. Attributes 
            are supported too. In case the last element in the dot-notated expression is a XML attribute the framework will automatically 
            find it.</para>
            
            <para>Of course this dot-notated syntax is very simple and might not be applicable for more complex tree walkings. 
            XPath is much more powerful - no doubt. However the dot-notated syntax might help those of you that are not familiar with XPath.
            So the dot-notation is supported wherever XPath expressions might apply.</para>
        </tip>  
    </section>
    
    <section id="message-header-validation">
        <title>Validate the message header</title>
        
        <para>Now that we have validated the message payload in various ways we are now interested in validating the message header. This is simple as you have to
        define the header name and the control value that you expect. Just add the following header validation to your receiving action.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;header&gt;
    &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
    &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
&lt;/header&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("getCustomerResponseReceiver")
        .header("Operation", "GetCustomer")
        .header("RequestTag", "${requestTag}");
}</programlisting>
        
        <para>Message headers often occur as name-value pairs. So each header element that we specify in validation has to be present in the received message. In addition 
        to that the header value has to fit the given control value. If a header entry is not found by its name or the value does not fit accordingly Citrus will raise 
        validation errors and the test case will fail.</para>
        
        <note>Sometimes message headers may not apply to the name-value pair pattern. For example SOAP headers can also contain XML fragments. Citrus supports these kind of
        headers too. Please see the SOAP chapter for more details on this specifica.</note>
    </section>
    
    <section id="message-content-extract">
        <title>Saving message content to variables</title>
        
        <para>Imagine you receive a message in your test holding some generated message identifier. You have no chance to predict the identifier value
        because it was generated at runtime by a foreign application. You can ignore the value in order to not break your validation, but in many cases you might need to return 
        this identifier in the respective response message. So Citrus needs to offer a way to save dynamic message content that is not known to the tester for reuse in later test steps. 
        The solution is simple and very powerful. We can extract dynamic values from received messages and save those to test variables. Add this code to your message receiving action.</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;extract&gt;
    &lt;header name=&quot;Operation&quot; variable=&quot;operation&quot;/&gt;
    &lt;message path=&quot;//MessageBody/Customer/Id&quot; variable=&quot;customerId&quot;/&gt;
&lt;/extract&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("getCustomerResponseReceiver")
        .extractFromHeader("Operation", "operation")
        .extractFromPayload("//MessageBody/Customer/Id", "customerId");
        
    echo("Extracted operation from header is: ${operation}");
    echo("Extracted customerId from header is: ${customerId}");
}</programlisting>
        
        <para>As you can see Citrus is able to store both header and message payload content into test variables. It does not matter if you use new test variables 
        or existing variables as target. The extraction will automatically create a new variable in case it does not exist. The time the variable was created from message extraction 
        all following test actions can access the variables as usual. So you could reuse the variable value in response messages or other test steps ahead.</para>
    </section>
    
    <section id="message-selector">
        <title>Message selectors</title>
        
        <para>The <emphasis>&lt;selector&gt;</emphasis> element inside the receiving action defines key-value pairs in order to 
        filter the messages being received. The key value pairs apply to the message headers. This means that a receiver will 
        only accept messages that meet the key-value pairs in its header. Using this mechanism you can explicitly listen for 
        messages that belong to your test. This is very helpful to avoid receiving messages from other tests that are still available 
        on the message destination.</para>
        
        <para>Lets say the tested software application keeps sending messages that belong to previous test cases. This could happen in retry 
        situations where the application's error handling automatically tries to solve a communication problem that occurred 
        during previous test cases. As a result a message destination (e.g. a JMS message queue) contains messages that are not valid any more for the currently 
        running test case. The test case might fail because the received message does not apply to the currently tested use case. The messages
        received are simply failing because the message content does not fit the expected one (e.g. correlation-ids, customer information 
        etc.).</para>
        
        <para>Now we have to find a way to avoid these problems. The test could filter the messages on a destination to only receive messages 
        that apply for the use case that is being tested. The Java Messaging System (JMS) came up with a message header selector that will 
        only accept messages that fit the expected header values.</para>
        
        <para>Let us have a closer look at a message selector inside a receiving action:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;selector&gt;
    &lt;element&gt; name="correlationId" value="Lx1x123456789"&lt;/element&gt;
    &lt;element&gt; name="operation" value="getOrders"&lt;/element&gt;
&lt;/selector&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("getCustomerResponseReceiver")
        .selector("correlationId='Lx1x123456789' AND operation='getOrders'");
}</programlisting>
        
        <para>This example shows how selectors work. The selector will only accept messages that meet the correlation id and the operation 
        in the header values. All other messages on the message destination are ignored. The selector elements are automatically associated to 
        each other using the logical AND operator. This means that the message selector string would look like this: <emphasis>correlationId = 'Lx1x123456789' AND operation = 'getOrders'</emphasis>.</para>
        
        <para>Instead of using several elements in the selector you can also define a selector string directly which gives you more power in constructing the selection logic yourself. This way
        you can use <emphasis>AND</emphasis> logical operators yourself.</para>
        
        <programlisting>&lt;selector&gt;
    &lt;value&gt;
        correlationId = 'Cx1x123456789' AND messageId = '987654321'
    &lt;/value&gt;
&lt;/selector&gt;</programlisting>
        
        <important>
            <para>In case you want to run tests in parallel message selectors become essential in your test cases. The different tests running 
            at the same time will steal messages from each other when you lack of message selection mechanisms.</para>
        </important>
        
        <important>
            <para>Previously only JMS message destinations offered support for message selectors! With Citrus version 1.2 we introduced message selector support for 
            Spring Integration message channels, too (see <xref linkend="message-channel-selector-support"/>).</para>
        </important>
    </section>
    
    <para>At this point you know the two most important test actions in Citrus. Sending and receiving actions will become the main components of your integration tests when dealing 
    with loosely coupled message based components in a SOA. It is very easy to create message flows, meaning a sequence of sending and receiving messages in your test case. 
    You can replicate use cases and test your message exchange with extended message validation possibilities.</para>
  </section>
  
  <section id="validation-callback">
    <title>Validation callback</title>
    
    <para>The Java DSL offers some additional validation tricks and functionalities when dealing with messages that are sent and received over Citrus. One of them is the validation
    callback functionality. With this piece you can marshal received message payloads and code validation steps on Java objects.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive(bookResponseMessageReceiver)
      .validationCallback(new MarshallingValidationCallback&lt;AddBookResponseMessage&gt;() {
          @Override
          public void validate(AddBookResponseMessage response, MessageHeaders headers) {
              Assert.isTrue(response.isSuccess());
          }
      });
}</programlisting>
    
    <para>By default the validation callback needs a XML unmarshaller implementation for transforming the XML payload to a Java object. Citrus will automatically search for a Unmarshaller bean
    in your Spring application context if nothing specific is set. Of course you can also set the unmarshaller explicitly.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@Autowired
private Unmarshaller unmarshaller;

@CitrusTest
public void receiveMessageTest() {
    receive(bookResponseMessageReceiver)
        .validationCallback(new MarshallingValidationCallback&lt;AddBookResponseMessage&gt;(unmarshaller) {
            @Override
            public void validate(AddBookResponseMessage response, MessageHeaders headers) {
                Assert.isTrue(response.isSuccess());
            }
        });
}</programlisting>

    <para>Obviously working on marshalled Java objects is much more comfortable than using the XML String concatenation. This is why you can also use this feature 
    when sending messages.</para>
    
    <para><emphasis>Java DSL</emphasis></para>
    <programlisting language="java">@Autowired
private Marshaller marshaller;

@CitrusTest
public void sendMessageTest() {
    send(bookRequestMessageSender)
            .payload(createAddBookRequestMessage("978-citrus:randomNumber(10)"), marshaller)
            .header("citrus_soap_action", "addBook");
}

private AddBookRequestMessage createAddBookRequestMessage(String isbn) {
    AddBookRequestMessage requestMessage = new AddBookRequestMessage();
    Book book = new Book();
    book.setAuthor("Foo");
    book.setTitle("FooTitle");
    book.setIsbn(isbn);
    book.setYear(2008);
    book.setRegistrationDate(Calendar.getInstance());
    requestMessage.setBook(book);
    return requestMessage;
}</programlisting>
  </section>
  
  <section id="groovy-utils">
    <title>Groovy utils for send and receive</title>
    
    <para>Groovy offers some nice and easy to use features for working with XML structures. You can use those in Citrus within the send and receive test actions in order
    to construct message payloads via Groovy scripts.</para>
    
    <section id="groovy-markupbuilder">
        <title>Groovy MarkupBuilder</title>
        
        <para>With the Groovy MarkupBuilder the tester may build XML message payloads in a simple way, without having to write the typical XML tag overhead. 
        For example we use the code listing from <xref linkend="message-sending"/>, but now we use a Groovy script instead of plain CDATA XML section. The Groovy MarkupBuilder 
        generates the XML message payload with exactly the same result:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;send with=&quot;getCustomerRequestMessageSender&quot;&gt;
    &lt;message&gt;
        &lt;builder type=&quot;groovy&quot;&gt;
            markupBuilder.RequestMessage{
                MessageHeader{
                    CorrelationId('${correlationId}')
                    Timestamp('2001-12-17T09:30:47.0Z')
                    RequestTag('_')
                    VersionId('2')
                }
                MessageBody{
                    Customer{
                        Id('1')
                    }
                }
            }
        &lt;/builder&gt;
        &lt;element path=&quot;/MessageHeader/RequestTag&quot; 
                    value=&quot;${requestTag}&quot;/&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;GetCustomer&quot;/&gt;
        &lt;element name=&quot;RequestTag&quot; value=&quot;${requestTag}&quot;/&gt;
    &lt;/header&gt;
&lt;/send&gt;</programlisting>
        
        <para>The MarkupBuilder code is directly written into the well-known message element. As you can see from the example above, the MarkupBuilder syntax 
        is very easy and follows the simple rule: <emphasis>markupBuilder.ROOT-ELEMENT{ CHILD-ELEMENTS }</emphasis>. However the tester has to follwow some simple rules and
        naming conventions when using the Citrus MarkupBuilder extension:</para>
        
        <itemizedlist>
            <listitem>The MarkupBuilder is accessed within the script over an object named <literal>markupBuilder</literal>. The name of the custom root element follows with all its child elements.</listitem>
            <listitem>Child elements may be defined within curly brackets after the root-element (the same applies for further nested child elements)</listitem>
            <listitem>Attributes and element values are defined within round brackets, after the element name</listitem>
            <listitem>Attribute and element values have to stand within apostrophes (e.g. attribute-name: 'attribute-value')</listitem>
        </itemizedlist>
        
        <para>The Groovy MarkupBuilder script may also be used within receive actions as shown in the following listing:</para>
        
        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;send with=&quot;helloRequestSender&quot;&gt;
    &lt;message&gt;
        &lt;builder type=&quot;groovy&quot; file=&quot;classpath:com/consol/citrus/groovy/helloRequest.groovy&quot;/&gt;
    &lt;/message&gt;
&lt;/send&gt;

&lt;receive with="helloResponseReceiver" timeout="5000"&gt;
    &lt;message&gt;
        &lt;builder type=&quot;groovy&quot;&gt;
            markupBuilder.HelloResponse(xmlns: 'http://www.consol.de/schemas/samples/sayHello.xsd'){
                MessageId('${messageId}')
                CorrelationId('${correlationId}')
                User('HelloService')
                Text('Hello ${user}')
            }
        &lt;/builder&gt;
    &lt;/message&gt;
&lt;/receive&gt;</programlisting>
        
        <para>As you can see it is also possible to define the script as external file resource. In addition to that namespace support is given as normal attribute definition 
        within the round brackets after the element name.</para>
        
        <para>The MarkupBuilder implementation in Groovy opens great possibilities in defining message payloads in Citrus test cases. We do not need to write XML tag 
        overhead and we can construct complex message payloads with Groovy logic like iterations and conditions. For detailed MarkupBuilder descriptions please see the
        official Groovy documentation.</para> 
    </section>

    <section id="groovy-xmlslurper">
        <title>Groovy XmlSlurper</title>

        <para>With the Groovy XmlSlurper you can easily validate XML message payloads without having to deal directly with XML. People who do not want to deal with XPath may 
        also like this validation alternative. The tester directly navigates through the message elements and uses simple code assertions in order to control the message content. 
        Here is an example how to validate messages with Groovy script:</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;receive with=&quot;helloResponseReceiver&quot; timeout=&quot;5000&quot;&gt;
    &lt;message&gt;
        &lt;validate&gt;
            &lt;script type=&quot;groovy&quot;&gt;
              assert root.children().size() == 4
              assert root.MessageId.text() == '${messageId}'
              assert root.CorrelationId.text() == '${correlationId}'
              assert root.User.text() == 'HelloService'
              assert root.Text.text() == 'Hello ' + context.getVariable("user")
            &lt;/script&gt;
        &lt;/validate&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloResponseReceiver")
        .validateScript("assert root.MessageId.text() == '${messageId}';" +
                        "assert root.CorrelationId.text() == '${correlationId}';")
        .header("Operation, "sayHello")
        .header("CorrelationId", "${correlationId}")
        .timeout(5000L);
}</programlisting>

        <para>The Groovy XmlSlurper validation script goes right into the message-tag instead of a XML control template or XPath validation. The Groovy script 
        supports Java <literal>assert</literal> statements for message element validation. The element navigation starts with the root element 
        reffered to as <literal>root</literal>. Based on this root element you can also access child elements and attributes. Just use the element names seperated 
        by a simple dot. Very easy! If you need the list of child elements use the <literal>children()</literal> function on any element. With the 
        <literal>text()</literal> function you get access to the element's text-value. The <literal>size()</literal> is very useful for validating the number of child 
        elements which completes the basic validation statements.</para>

        <para>As you can see from the example, we may use test variables within the validation script, too. Also not very surprising you may use external file resources
        as validaton scripts. The syntax looks like follows:</para>

        <para><emphasis>XML DSL</emphasis></para>
        <programlisting>&lt;receive with=&quot;helloResponseReceiver&quot; timeout=&quot;5000&quot;&gt;
    &lt;message&gt;
        &lt;validate&gt;
          &lt;script type=&quot;groovy&quot; file=&quot;classpath:validationScript.groovy&quot;/&gt;
        &lt;/validate&gt;
    &lt;/message&gt;
    &lt;header&gt;
        &lt;element name=&quot;Operation&quot; value=&quot;sayHello&quot;/&gt;
        &lt;element name=&quot;CorrelationId&quot; value=&quot;${correlationId}&quot;/&gt;
    &lt;/header&gt;
&lt;/receive&gt;</programlisting>

        <para><emphasis>Java DSL</emphasis></para>
        <programlisting language="java">@CitrusTest
public void receiveMessageTest() {
    receive("helloResponseReceiver")
        .validateScript(new FileSystemResource("validationScript.groovy"))
        .header("Operation, "sayHello")
        .header("CorrelationId", "${correlationId}")
        .timeout(5000L);
}</programlisting>

        <note>You can use the Groovy validation script in combination with other validation types like XML tree comparison and XPath validation.</note>

        <tip>For further information on the Groovy XmlSlurper please see the official Groovy website and documentation</tip>
    </section>
  </section>
  
</chapter>
