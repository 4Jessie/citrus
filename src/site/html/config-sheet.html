<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<body>
<div class="container box">
  <h1 class="page-header">Configuration sheet <small>How to setup Citrus configuration components</small></h1>

  <p>Citrus components are configured in the Spring application context (<b>citrus-context.xml</b>) as bean definitions.
    The Citrus components do follow specific XML namespaces and XSD schema rules. You may have to add these namespace
    definitions to the configuration file root element.</p>

  <div class="container">
    <div class="row">
      <div class="span11">
        <h3 class="config-header">Channels</h3>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>Message channels do represent a in memory messaging solution in Citrus. Producer and consumer components are linked via channels. As this
          transport mechanism is also used in Spring integration API you are able to connect to all Spring integration message adapters via channels.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:message-channel id=&quot;helloServiceChannel&quot;/&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span11">
        <h4>Channel Endpoints</h4>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>Producer and consumer components do send/receive messages to/from a channel endpoint. By default the endpoint is asynchronous when configured
          in the Citrus application context.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:channel-endpoint id=&quot;helloServiceChannelEndpoint&quot;
                        channel-name=&quot;helloServiceChannel&quot;/&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>Interacting with the endpoints in a test case is quite easy. Just reference the id of the endpoint in your send and receive test actions.
          This pattern is valid for all endpoint components in Citrus.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;send with=&quot;helloServiceChannelEndpoint&quot;&gt;
  &lt;message&gt;...&lt;/message&gt;
&lt;/send&gt;

&lt;receive with=&quot;helloServiceChannelEndpoint&quot;&gt;
  &lt;message&gt;...&lt;/message&gt;
&lt;/receive&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span11">
        <h4>Synchronous Channel Endpoints</h4>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>By default channels are asynchronous. But sometimes it may be necessary to wait for a synchronous response message. Or in the other direction to send back
          a synchronous response message. In Citrus synchronous communication is also represented by endpoints. The synchronous endpoints will wait for response messages
          to arrive on a reply destination. By default this reply destination is temporary for each message sent/received.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:channel-sync-endpoint id=&quot;helloServiceSyncChannelEndpoint&quot;
                        channel-name=&quot;helloServiceChannel&quot;/&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>When initially sending a message to this endpoint the producer will wait synchronously for the response message to arrive on the reply destination.
          You can receive the reply message in your test case using the same endpoint component.</p>

        <p>When initially receiving a message from a synchronous channel endpoint you are able to send a synchronous response back. Again just use the same endpoint to
          send back the reply message in your test case. The handling of temporary reply destinations is done automatically in the back.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;send with=&quot;helloServiceSyncChannelEndpoint&quot;&gt;
  &lt;message&gt;...&lt;/message&gt;
&lt;/send&gt;

&lt;receive with=&quot;helloServiceSyncChannelEndpoint&quot;&gt;
  &lt;message&gt;...&lt;/message&gt;
&lt;/receive&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span11">
        <h3 class="config-header">JMS Support</h3>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>The Java Message Service (JMS) is a well known and commonly used messaging API. Producer and consumer do exchange messages via TCP/IP protocol
          using a JMS message broker. With JMS you can construct both synchronous and asynchronous communication patterns.</p>
      </div>
      <div class="span7"></div>
    </div>

    <div class="row">
      <div class="span4">
        <p>When using JMS components in Citrus you need a connection factory. The default bean id <b>connectionFactory</b>
          is automatically recognized by all Citrus JMS components.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;bean id=&quot;connectionFactory&quot; class=&quot;org.apache.activemq.ActiveMQConnectionFactory&quot;&gt;
    &lt;property name=&quot;brokerURL&quot; value=&quot;tcp://localhost:61616&quot; /&gt;
&lt;/bean&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span11">
        <h4>JMS Endpoints</h4>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>A JMS endpoint can be a queue or a topic destination. Producer and consumer components can send/receive messages
          to/from this endpoint. By default the endpoint is asynchronous, which means that you send or receive a message and you are done.
          JMS endpoints are configured in the Citrus application context.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:jms-endpoint id=&quot;helloServiceQueueEndpoint&quot;
                        destination-name=&quot;Citrus.HelloService.Request.Queue&quot;
                        timeout=&quot;10000&quot;/&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>Besides defining a JMS endpoint with a destination name you can also reference a destination object
          instance directly. This way you could do a JNDI lookup for instance.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:jms-endpoint id=&quot;helloServiceQueueEndpoint&quot;
                        destination=&quot;helloServiceQueue&quot;/&gt;

&lt;amq:queue id=&quot;helloServiceQueue&quot; physicalName=&quot;Citrus.HelloService.Request.Queue&quot;/></pre>
      </div>
    </div>

    <div class="row">
      <div class="span11">
        <h4>JMS Topic Endpoints</h4>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>If you want to interact with a topic destination just use the <b>sub-pub-domain</b> attribute
          which stands for <b>pub</b>lish <b>sub</b>scribe communication pattern. All consumers connected to a topic destination
          will receive the messages simultaneously.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:jms-endpoint id=&quot;helloServiceTopicEndpoint&quot;
                        destination-name=&quot;Citrus.HelloService.Request.Topic&quot;
                        pub-sub-domain=&quot;true&quot;/&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span11">
        <h4>JMS Synchronous Endpoints</h4>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>Synchronous JMS communication is also represented by endpoints. The synchronous JMS endpoints will wait for response messages to arrive
          on some reply destination. By default this reply destination is temporary for each message sent/received.</p>
      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:jms-sync-endpoint id=&quot;helloServiceSyncEndpoint&quot;
                        destination-name=&quot;Citrus.HelloService.InOut.Queue&quot;/&gt;</pre>
      </div>
    </div>

    <div class="row">
      <div class="span4">
        <p>If you rather want to define a static reply destination you can do so, too. You may need to work with message selectors then in order to pick
          the response message that belongs to a specific communication handshake.</p>

      </div>
      <div class="span7">
        <pre class="prettyprint">&lt;citrus:jms-sync-endpoint id=&quot;helloServiceSyncEndpoint&quot;
                        destination-name=&quot;Citrus.HelloService.InOut.Queue&quot;
                        reply-destination-name=&quot;Citrus.HelloService.Reply.Queue&quot;/&gt;</pre>
      </div>
    </div>
  </div>
</div>

</body>
</html>